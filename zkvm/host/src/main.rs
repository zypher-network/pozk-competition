// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    COMPETITION_ELF, COMPETITION_ID
};
use risc0_zkvm::{get_prover_server, ExecutorEnv, ProverOpts};
use sha2::{Sha256, Digest as _};
use sha3::Keccak256;

/// INPUT=http://localhost:9098/tasks/1 cargo run --release
#[tokio::main]
async fn main() {
    let input_path = std::env::var("INPUT").expect("env INPUT missing");
    let bytes = reqwest::get(&input_path)
        .await
        .unwrap()
        .bytes()
        .await
        .unwrap();

    // parse inputs and publics
    let mut input_len_bytes = [0u8; 4];
    input_len_bytes.copy_from_slice(&bytes[0..4]);
    let input_len = u32::from_be_bytes(input_len_bytes) as usize;

    let input = bytes[4..input_len + 4].to_vec();
    let publics = bytes[input_len + 4..].to_vec();

    // pre-check publics  // FIXME use risc-v runtime
    let mut hasher1 = Sha256::new();
    hasher1.update(&input);
    let result1 = hasher1.finalize().to_vec();

    let mut hasher2 = Keccak256::new();
    hasher2.update(&result1);
    let last = hasher2.finalize().to_vec();

    // generate risc0 groth16 digest
    let mut encode_hash = vec![32, 0, 0, 0]; // fixed 32 size
    for i in last.iter() {
        encode_hash.extend((*i as u32).to_le_bytes().to_vec());
    }
    let mut hasher3 = Sha256::new();
    hasher3.update(&encode_hash);
    let checked_publics = hasher3.finalize().to_vec();
    assert_eq!(checked_publics, publics);

    // start zkp
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    let prover = get_prover_server(&ProverOpts::groth16()).unwrap();
    let prove_info = prover.prove(env, COMPETITION_ELF).unwrap();
    let receipt = prove_info.receipt;

    // serialize proof
    let g_proof = &receipt.inner.groth16().unwrap();
    let mut proof = g_proof.verifier_parameters.as_bytes()[..4].to_vec(); // selector
    proof.extend(&g_proof.seal);

    // check proof
    receipt.verify(COMPETITION_ID).unwrap();

    let client = reqwest::Client::new();
    client.post(&input_path).body(proof).send().await.unwrap();
}

#[cfg(test)]
mod tests {
    use super::*;
    use risc0_zkvm::sha::Digest;

    #[test]
    fn test_input_output() {
        let image_id: Digest = COMPETITION_ID.into();

        let input = [1u8; 32];

        let mut hasher1 = Sha256::new();
        hasher1.update(&input);
        let result1 = hasher1.finalize().to_vec();

        let mut hasher2 = Keccak256::new();
        hasher2.update(&result1);
        let last = hasher2.finalize().to_vec();

        // generate risc0 groth16 digest
        let mut encode_hash = vec![32, 0, 0, 0]; // fixed 32 size
        for i in last.iter() {
            encode_hash.extend((*i as u32).to_le_bytes().to_vec());
        }
        let mut hasher3 = Sha256::new();
        hasher3.update(&encode_hash);
        let publics = hasher3.finalize().to_vec();

        println!("image  : {}", image_id);
        println!("inputs : {}", hex::encode(input));
        println!("publics: {}", hex::encode(publics));
    }
}
