// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    COMPETITION_ELF, COMPETITION_ID
};
use risc0_zkvm::{get_prover_server, ExecutorEnv, ProverOpts};
use sha2::{Sha256, Digest as _};
use sha3::Keccak256;

#[tokio::main]
async fn main() {
    let input = [0u8; 32]; // DEMO input

    // start zkp
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    let prover = get_prover_server(&ProverOpts::groth16()).unwrap();
    let prove_info = prover.prove(env, COMPETITION_ELF).unwrap();
    let receipt = prove_info.receipt;

    // serialize proof
    let g_proof = &receipt.inner.groth16().unwrap();
    let mut proof = g_proof.verifier_parameters.as_bytes()[..4].to_vec(); // selector
    proof.extend(&g_proof.seal);

    // check proof
    receipt.verify(COMPETITION_ID).unwrap();

    println!("proof: {}", hex::encode(&proof));
}

#[cfg(test)]
mod tests {
    use super::*;
    use risc0_zkvm::sha::Digest;

    #[test]
    fn test_input_output() {
        let image_id: Digest = COMPETITION_ID.into();

        let input = [1u8; 32];

        let mut hasher1 = Sha256::new();
        hasher1.update(&input);
        let result1 = hasher1.finalize().to_vec();

        let mut hasher2 = Keccak256::new();
        hasher2.update(&result1);
        let last = hasher2.finalize().to_vec();

        // generate risc0 groth16 digest
        let mut encode_hash = vec![32, 0, 0, 0]; // fixed 32 size
        for i in last.iter() {
            encode_hash.extend((*i as u32).to_le_bytes().to_vec());
        }
        let mut hasher3 = Sha256::new();
        hasher3.update(&encode_hash);
        let publics = hasher3.finalize().to_vec();

        println!("image  : {}", image_id);
        println!("inputs : {}", hex::encode(input));
        println!("publics: {}", hex::encode(publics));
    }
}
